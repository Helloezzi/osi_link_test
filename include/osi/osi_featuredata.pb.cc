// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_featuredata.proto

#include "osi_featuredata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace osi3 {
constexpr FeatureData::FeatureData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : radar_sensor_()
  , lidar_sensor_()
  , ultrasonic_sensor_()
  , camera_sensor_()
  , version_(nullptr){}
struct FeatureDataDefaultTypeInternal {
  constexpr FeatureDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FeatureDataDefaultTypeInternal() {}
  union {
    FeatureData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
constexpr SensorDetectionHeader::SensorDetectionHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : measurement_time_(nullptr)
  , mounting_position_(nullptr)
  , mounting_position_rmse_(nullptr)
  , sensor_id_(nullptr)
  , cycle_counter_(uint64_t{0u})
  , data_qualifier_(0)

  , number_of_valid_detections_(0u)
  , extended_qualifier_(0)
{}
struct SensorDetectionHeaderDefaultTypeInternal {
  constexpr SensorDetectionHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorDetectionHeaderDefaultTypeInternal() {}
  union {
    SensorDetectionHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;
constexpr RadarDetectionData::RadarDetectionData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : detection_()
  , header_(nullptr){}
struct RadarDetectionDataDefaultTypeInternal {
  constexpr RadarDetectionDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RadarDetectionDataDefaultTypeInternal() {}
  union {
    RadarDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;
constexpr RadarDetection::RadarDetection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_id_(nullptr)
  , position_(nullptr)
  , position_rmse_(nullptr)
  , ambiguity_id_(nullptr)
  , existence_probability_(0)
  , radial_velocity_(0)
  , radial_velocity_rmse_(0)
  , rcs_(0)
  , snr_(0)
  , point_target_probability_(0)
  , classification_(0)
{}
struct RadarDetectionDefaultTypeInternal {
  constexpr RadarDetectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RadarDetectionDefaultTypeInternal() {}
  union {
    RadarDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;
constexpr LidarDetectionData::LidarDetectionData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : detection_()
  , header_(nullptr){}
struct LidarDetectionDataDefaultTypeInternal {
  constexpr LidarDetectionDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LidarDetectionDataDefaultTypeInternal() {}
  union {
    LidarDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;
constexpr LidarDetection::LidarDetection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_id_(nullptr)
  , position_(nullptr)
  , position_rmse_(nullptr)
  , existence_probability_(0)
  , height_(0)
  , height_rmse_(0)
  , intensity_(0)
  , free_space_probability_(0)
  , reflectivity_(0)
  , echo_pulse_width_(0)
  , classification_(0)
{}
struct LidarDetectionDefaultTypeInternal {
  constexpr LidarDetectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LidarDetectionDefaultTypeInternal() {}
  union {
    LidarDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;
constexpr UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : max_range_(0)
  , number_of_valid_indirect_detections_(0u){}
struct UltrasonicDetectionSpecificHeaderDefaultTypeInternal {
  constexpr UltrasonicDetectionSpecificHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UltrasonicDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    UltrasonicDetectionSpecificHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;
constexpr UltrasonicDetectionData::UltrasonicDetectionData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : detection_()
  , indirect_detection_()
  , header_(nullptr)
  , specific_header_(nullptr){}
struct UltrasonicDetectionDataDefaultTypeInternal {
  constexpr UltrasonicDetectionDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UltrasonicDetectionDataDefaultTypeInternal() {}
  union {
    UltrasonicDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;
constexpr UltrasonicDetection::UltrasonicDetection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_id_(nullptr)
  , existence_probability_(0)
  , distance_(0){}
struct UltrasonicDetectionDefaultTypeInternal {
  constexpr UltrasonicDetectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UltrasonicDetectionDefaultTypeInternal() {}
  union {
    UltrasonicDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;
constexpr UltrasonicIndirectDetection::UltrasonicIndirectDetection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_id_(nullptr)
  , receiver_id_(nullptr)
  , receiver_origin_(nullptr)
  , existence_probability_(0)
  , ellipsoid_radial_(0)
  , ellipsoid_axial_(0){}
struct UltrasonicIndirectDetectionDefaultTypeInternal {
  constexpr UltrasonicIndirectDetectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UltrasonicIndirectDetectionDefaultTypeInternal() {}
  union {
    UltrasonicIndirectDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;
constexpr CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : number_of_valid_points_(0u){}
struct CameraDetectionSpecificHeaderDefaultTypeInternal {
  constexpr CameraDetectionSpecificHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    CameraDetectionSpecificHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;
constexpr CameraDetectionData::CameraDetectionData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : detection_()
  , point_()
  , header_(nullptr)
  , specific_header_(nullptr){}
struct CameraDetectionDataDefaultTypeInternal {
  constexpr CameraDetectionDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraDetectionDataDefaultTypeInternal() {}
  union {
    CameraDetectionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;
constexpr CameraDetection::CameraDetection(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_id_(nullptr)
  , time_difference_(nullptr)
  , ambiguity_id_(nullptr)
  , color_description_(nullptr)
  , existence_probability_(0)
  , image_shape_type_(0)

  , shape_classification_background_(false)
  , shape_classification_foreground_(false)
  , shape_classification_flat_(false)
  , shape_classification_upright_(false)
  , shape_classification_ground_(false)
  , shape_classification_sky_(false)
  , shape_classification_vegetation_(false)
  , shape_classification_road_(false)
  , shape_classification_non_driving_lane_(false)
  , shape_classification_non_road_(false)
  , shape_classification_stationary_object_(false)
  , shape_classification_moving_object_(false)
  , shape_classification_landmark_(false)
  , shape_classification_traffic_sign_(false)
  , shape_classification_traffic_light_(false)
  , shape_classification_road_marking_(false)
  , shape_classification_vehicle_(false)
  , shape_classification_pedestrian_(false)
  , shape_classification_animal_(false)
  , shape_classification_pedestrian_front_(false)
  , shape_classification_pedestrian_side_(false)
  , shape_classification_pedestrian_rear_(false)
  , color_(0)

  , shape_classification_probability_(0)
  , color_probability_(0)
  , first_point_index_(0u)
  , number_of_points_(0u){}
struct CameraDetectionDefaultTypeInternal {
  constexpr CameraDetectionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraDetectionDefaultTypeInternal() {}
  union {
    CameraDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;
constexpr CameraPoint::CameraPoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : point_(nullptr)
  , point_rmse_(nullptr)
  , existence_probability_(0){}
struct CameraPointDefaultTypeInternal {
  constexpr CameraPointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraPointDefaultTypeInternal() {}
  union {
    CameraPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraPointDefaultTypeInternal _CameraPoint_default_instance_;
}  // namespace osi3
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_osi_5ffeaturedata_2eproto[14];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_osi_5ffeaturedata_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_osi_5ffeaturedata_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_osi_5ffeaturedata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, version_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, radar_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, lidar_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, ultrasonic_sensor_),
  PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, camera_sensor_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, measurement_time_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, cycle_counter_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, mounting_position_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, mounting_position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, data_qualifier_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, number_of_valid_detections_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, extended_qualifier_),
  0,
  4,
  1,
  2,
  5,
  6,
  3,
  7,
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, header_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, detection_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, position_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, radial_velocity_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, radial_velocity_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, rcs_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, snr_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, point_target_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, ambiguity_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, classification_),
  4,
  0,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  3,
  10,
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, header_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, detection_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, position_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, position_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, height_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, height_rmse_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, intensity_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, free_space_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, classification_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, reflectivity_),
  PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, echo_pulse_width_),
  3,
  0,
  1,
  2,
  4,
  5,
  6,
  7,
  10,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, max_range_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, number_of_valid_indirect_detections_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, header_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, specific_header_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, detection_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, indirect_detection_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, distance_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, ellipsoid_radial_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, ellipsoid_axial_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, receiver_origin_),
  3,
  0,
  4,
  5,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, number_of_valid_points_),
  0,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, header_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, specific_header_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, detection_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, point_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, object_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, time_difference_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, image_shape_type_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_background_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_foreground_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_flat_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_upright_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_ground_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_sky_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_vegetation_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_road_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_non_driving_lane_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_non_road_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_stationary_object_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_moving_object_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_landmark_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_traffic_sign_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_traffic_light_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_road_marking_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_vehicle_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_pedestrian_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_animal_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_pedestrian_front_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_pedestrian_side_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_pedestrian_rear_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, shape_classification_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, color_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, color_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, ambiguity_id_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, first_point_index_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, number_of_points_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, color_description_),
  4,
  0,
  1,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  29,
  28,
  30,
  2,
  31,
  32,
  3,
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, existence_probability_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, point_),
  PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, point_rmse_),
  2,
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::osi3::FeatureData)},
  { 16, 30, -1, sizeof(::osi3::SensorDetectionHeader)},
  { 38, 46, -1, sizeof(::osi3::RadarDetectionData)},
  { 48, 65, -1, sizeof(::osi3::RadarDetection)},
  { 76, 84, -1, sizeof(::osi3::LidarDetectionData)},
  { 86, 103, -1, sizeof(::osi3::LidarDetection)},
  { 114, 122, -1, sizeof(::osi3::UltrasonicDetectionSpecificHeader)},
  { 124, 134, -1, sizeof(::osi3::UltrasonicDetectionData)},
  { 138, 147, -1, sizeof(::osi3::UltrasonicDetection)},
  { 150, 162, -1, sizeof(::osi3::UltrasonicIndirectDetection)},
  { 168, 175, -1, sizeof(::osi3::CameraDetectionSpecificHeader)},
  { 176, 186, -1, sizeof(::osi3::CameraDetectionData)},
  { 190, 229, -1, sizeof(::osi3::CameraDetection)},
  { 262, 271, -1, sizeof(::osi3::CameraPoint)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_FeatureData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_SensorDetectionHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_RadarDetectionData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_RadarDetection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_LidarDetectionData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_LidarDetection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_UltrasonicDetectionSpecificHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_UltrasonicDetectionData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_UltrasonicDetection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_UltrasonicIndirectDetection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_CameraDetectionSpecificHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_CameraDetectionData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_CameraDetection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::osi3::_CameraPoint_default_instance_),
};

const char descriptor_table_protodef_osi_5ffeaturedata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025osi_featuredata.proto\022\004osi3\032\021osi_versi"
  "on.proto\032\020osi_common.proto\"\202\002\n\013FeatureDa"
  "ta\022\'\n\007version\030\001 \001(\0132\026.osi3.InterfaceVers"
  "ion\022.\n\014radar_sensor\030\002 \003(\0132\030.osi3.RadarDe"
  "tectionData\022.\n\014lidar_sensor\030\003 \003(\0132\030.osi3"
  ".LidarDetectionData\0228\n\021ultrasonic_sensor"
  "\030\004 \003(\0132\035.osi3.UltrasonicDetectionData\0220\n"
  "\rcamera_sensor\030\005 \003(\0132\031.osi3.CameraDetect"
  "ionData\"\352\t\n\025SensorDetectionHeader\022)\n\020mea"
  "surement_time\030\001 \001(\0132\017.osi3.Timestamp\022\025\n\r"
  "cycle_counter\030\002 \001(\004\0221\n\021mounting_position"
  "\030\003 \001(\0132\026.osi3.MountingPosition\0226\n\026mounti"
  "ng_position_rmse\030\004 \001(\0132\026.osi3.MountingPo"
  "sition\022A\n\016data_qualifier\030\005 \001(\0162).osi3.Se"
  "nsorDetectionHeader.DataQualifier\022\"\n\032num"
  "ber_of_valid_detections\030\006 \001(\r\022#\n\tsensor_"
  "id\030\007 \001(\0132\020.osi3.Identifier\022I\n\022extended_q"
  "ualifier\030\010 \001(\0162-.osi3.SensorDetectionHea"
  "der.ExtendedQualifier\"\215\002\n\rDataQualifier\022"
  "\032\n\026DATA_QUALIFIER_UNKNOWN\020\000\022\030\n\024DATA_QUAL"
  "IFIER_OTHER\020\001\022\034\n\030DATA_QUALIFIER_AVAILABL"
  "E\020\002\022$\n DATA_QUALIFIER_AVAILABLE_REDUCED\020"
  "\003\022 \n\034DATA_QUALIFIER_NOT_AVAILABLE\020\004\022\034\n\030D"
  "ATA_QUALIFIER_BLINDNESS\020\005\022&\n\"DATA_QUALIF"
  "IER_TEMPORARY_AVAILABLE\020\006\022\032\n\026DATA_QUALIF"
  "IER_INVALID\020\007\"\274\004\n\021ExtendedQualifier\022\036\n\032E"
  "XTENDED_QUALIFIER_UNKNOWN\020\000\022\034\n\030EXTENDED_"
  "QUALIFIER_OTHER\020\001\022,\n(EXTENDED_QUALIFIER_"
  "NORMAL_OPERATION_MODE\020\002\022\'\n#EXTENDED_QUAL"
  "IFIER_POWER_UP_OR_DOWN\020\003\022,\n(EXTENDED_QUA"
  "LIFIER_SENSOR_NOT_CALIBRATED\020\004\022%\n!EXTEND"
  "ED_QUALIFIER_SENSOR_BLOCKED\020\005\022(\n$EXTENDE"
  "D_QUALIFIER_SENSOR_MISALIGNED\020\006\0229\n5EXTEN"
  "DED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_C"
  "ONDITION\020\007\022,\n(EXTENDED_QUALIFIER_REDUCED"
  "_FIELD_OF_VIEW\020\010\022*\n&EXTENDED_QUALIFIER_I"
  "NPUT_NOT_AVAILABLE\020\t\022&\n\"EXTENDED_QUALIFI"
  "ER_INTERNAL_REASON\020\n\022+\n\'EXTENDED_QUALIFI"
  "ER_EXTERNAL_DISTURBANCE\020\013\022)\n%EXTENDED_QU"
  "ALIFIER_BEGINNING_BLOCKAGE\020\014\"j\n\022RadarDet"
  "ectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Sensor"
  "DetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024.osi"
  "3.RadarDetection\"\365\002\n\016RadarDetection\022\035\n\025e"
  "xistence_probability\030\001 \001(\001\022#\n\tobject_id\030"
  "\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030\003 \001("
  "\0132\021.osi3.Spherical3d\022(\n\rposition_rmse\030\004 "
  "\001(\0132\021.osi3.Spherical3d\022\027\n\017radial_velocit"
  "y\030\005 \001(\001\022\034\n\024radial_velocity_rmse\030\006 \001(\001\022\013\n"
  "\003rcs\030\007 \001(\001\022\013\n\003snr\030\010 \001(\001\022 \n\030point_target_"
  "probability\030\t \001(\001\022&\n\014ambiguity_id\030\n \001(\0132"
  "\020.osi3.Identifier\0225\n\016classification\030\013 \001("
  "\0162\035.osi3.DetectionClassification\"j\n\022Lida"
  "rDetectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Se"
  "nsorDetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024"
  ".osi3.LidarDetection\"\342\002\n\016LidarDetection\022"
  "\035\n\025existence_probability\030\001 \001(\001\022#\n\tobject"
  "_id\030\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030"
  "\003 \001(\0132\021.osi3.Spherical3d\022(\n\rposition_rms"
  "e\030\004 \001(\0132\021.osi3.Spherical3d\022\016\n\006height\030\005 \001"
  "(\001\022\023\n\013height_rmse\030\006 \001(\001\022\021\n\tintensity\030\007 \001"
  "(\001\022\036\n\026free_space_probability\030\010 \001(\001\0225\n\016cl"
  "assification\030\t \001(\0162\035.osi3.DetectionClass"
  "ification\022\024\n\014reflectivity\030\n \001(\001\022\030\n\020echo_"
  "pulse_width\030\013 \001(\001\"c\n!UltrasonicDetection"
  "SpecificHeader\022\021\n\tmax_range\030\001 \001(\001\022+\n#num"
  "ber_of_valid_indirect_detections\030\002 \001(\r\"\365"
  "\001\n\027UltrasonicDetectionData\022+\n\006header\030\001 \001"
  "(\0132\033.osi3.SensorDetectionHeader\022@\n\017speci"
  "fic_header\030\003 \001(\0132\'.osi3.UltrasonicDetect"
  "ionSpecificHeader\022,\n\tdetection\030\002 \003(\0132\031.o"
  "si3.UltrasonicDetection\022=\n\022indirect_dete"
  "ction\030\004 \003(\0132!.osi3.UltrasonicIndirectDet"
  "ection\"k\n\023UltrasonicDetection\022\035\n\025existen"
  "ce_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132"
  "\020.osi3.Identifier\022\020\n\010distance\030\003 \001(\001\"\344\001\n\033"
  "UltrasonicIndirectDetection\022\035\n\025existence"
  "_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132\020."
  "osi3.Identifier\022\030\n\020ellipsoid_radial\030\003 \001("
  "\001\022\027\n\017ellipsoid_axial\030\004 \001(\001\022%\n\013receiver_i"
  "d\030\005 \001(\0132\020.osi3.Identifier\022\'\n\017receiver_or"
  "igin\030\006 \001(\0132\016.osi3.Vector3d\"\?\n\035CameraDete"
  "ctionSpecificHeader\022\036\n\026number_of_valid_p"
  "oints\030\001 \001(\r\"\314\001\n\023CameraDetectionData\022+\n\006h"
  "eader\030\001 \001(\0132\033.osi3.SensorDetectionHeader"
  "\022<\n\017specific_header\030\003 \001(\0132#.osi3.CameraD"
  "etectionSpecificHeader\022(\n\tdetection\030\002 \003("
  "\0132\025.osi3.CameraDetection\022 \n\005point\030\004 \003(\0132"
  "\021.osi3.CameraPoint\"\244\016\n\017CameraDetection\022\035"
  "\n\025existence_probability\030\001 \001(\001\022#\n\tobject_"
  "id\030\002 \001(\0132\020.osi3.Identifier\022(\n\017time_diffe"
  "rence\030\003 \001(\0132\017.osi3.Timestamp\022>\n\020image_sh"
  "ape_type\030\004 \001(\0162$.osi3.CameraDetection.Im"
  "ageShapeType\022\'\n\037shape_classification_bac"
  "kground\030\005 \001(\010\022\'\n\037shape_classification_fo"
  "reground\030\006 \001(\010\022!\n\031shape_classification_f"
  "lat\030\007 \001(\010\022$\n\034shape_classification_uprigh"
  "t\030\010 \001(\010\022#\n\033shape_classification_ground\030\t"
  " \001(\010\022 \n\030shape_classification_sky\030\n \001(\010\022\'"
  "\n\037shape_classification_vegetation\030\013 \001(\010\022"
  "!\n\031shape_classification_road\030\014 \001(\010\022-\n%sh"
  "ape_classification_non_driving_lane\030\r \001("
  "\010\022%\n\035shape_classification_non_road\030\016 \001(\010"
  "\022.\n&shape_classification_stationary_obje"
  "ct\030\017 \001(\010\022*\n\"shape_classification_moving_"
  "object\030\020 \001(\010\022%\n\035shape_classification_lan"
  "dmark\030\021 \001(\010\022)\n!shape_classification_traf"
  "fic_sign\030\022 \001(\010\022*\n\"shape_classification_t"
  "raffic_light\030\023 \001(\010\022)\n!shape_classificati"
  "on_road_marking\030\024 \001(\010\022$\n\034shape_classific"
  "ation_vehicle\030\025 \001(\010\022\'\n\037shape_classificat"
  "ion_pedestrian\030\026 \001(\010\022#\n\033shape_classifica"
  "tion_animal\030\027 \001(\010\022-\n%shape_classificatio"
  "n_pedestrian_front\030\030 \001(\010\022,\n$shape_classi"
  "fication_pedestrian_side\030\031 \001(\010\022,\n$shape_"
  "classification_pedestrian_rear\030\032 \001(\010\022(\n "
  "shape_classification_probability\030\033 \001(\001\022*"
  "\n\005color\030\034 \001(\0162\033.osi3.CameraDetection.Col"
  "or\022\031\n\021color_probability\030\035 \001(\001\022&\n\014ambigui"
  "ty_id\030\036 \001(\0132\020.osi3.Identifier\022\031\n\021first_p"
  "oint_index\030\037 \001(\r\022\030\n\020number_of_points\030  \001"
  "(\r\0221\n\021color_description\030! \001(\0132\026.osi3.Col"
  "orDescription\"\331\001\n\005Color\022\021\n\rCOLOR_UNKNOWN"
  "\020\000\022\017\n\013COLOR_OTHER\020\001\022\017\n\013COLOR_BLACK\020\002\022\016\n\n"
  "COLOR_GREY\020\003\022\017\n\013COLOR_WHITE\020\004\022\020\n\014COLOR_Y"
  "ELLOW\020\005\022\020\n\014COLOR_ORANGE\020\006\022\r\n\tCOLOR_RED\020\007"
  "\022\020\n\014COLOR_VIOLET\020\010\022\016\n\nCOLOR_BLUE\020\t\022\017\n\013CO"
  "LOR_GREEN\020\n\022\024\n\020COLOR_REFLECTIVE\020\013\"\375\001\n\016Im"
  "ageShapeType\022\034\n\030IMAGE_SHAPE_TYPE_UNKNOWN"
  "\020\000\022\032\n\026IMAGE_SHAPE_TYPE_OTHER\020\001\022\032\n\026IMAGE_"
  "SHAPE_TYPE_POINT\020\002\022\030\n\024IMAGE_SHAPE_TYPE_B"
  "OX\020\003\022\034\n\030IMAGE_SHAPE_TYPE_ELLIPSE\020\004\022\034\n\030IM"
  "AGE_SHAPE_TYPE_POLYGON\020\005\022\035\n\031IMAGE_SHAPE_"
  "TYPE_POLYLINE\020\006\022 \n\034IMAGE_SHAPE_TYPE_POIN"
  "T_CLOUD\020\007\"u\n\013CameraPoint\022\035\n\025existence_pr"
  "obability\030\001 \001(\001\022 \n\005point\030\002 \001(\0132\021.osi3.Sp"
  "herical3d\022%\n\npoint_rmse\030\003 \001(\0132\021.osi3.Sph"
  "erical3d*\206\002\n\027DetectionClassification\022$\n "
  "DETECTION_CLASSIFICATION_UNKNOWN\020\000\022\"\n\036DE"
  "TECTION_CLASSIFICATION_OTHER\020\001\022$\n DETECT"
  "ION_CLASSIFICATION_INVALID\020\002\022$\n DETECTIO"
  "N_CLASSIFICATION_CLUTTER\020\003\022)\n%DETECTION_"
  "CLASSIFICATION_OVERDRIVABLE\020\004\022*\n&DETECTI"
  "ON_CLASSIFICATION_UNDERDRIVABLE\020\005B\002H\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_osi_5ffeaturedata_2eproto_deps[2] = {
  &::descriptor_table_osi_5fcommon_2eproto,
  &::descriptor_table_osi_5fversion_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_osi_5ffeaturedata_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_osi_5ffeaturedata_2eproto = {
  false, false, 5717, descriptor_table_protodef_osi_5ffeaturedata_2eproto, "osi_featuredata.proto", 
  &descriptor_table_osi_5ffeaturedata_2eproto_once, descriptor_table_osi_5ffeaturedata_2eproto_deps, 2, 14,
  schemas, file_default_instances, TableStruct_osi_5ffeaturedata_2eproto::offsets,
  file_level_metadata_osi_5ffeaturedata_2eproto, file_level_enum_descriptors_osi_5ffeaturedata_2eproto, file_level_service_descriptors_osi_5ffeaturedata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_osi_5ffeaturedata_2eproto_getter() {
  return &descriptor_table_osi_5ffeaturedata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_osi_5ffeaturedata_2eproto(&descriptor_table_osi_5ffeaturedata_2eproto);
namespace osi3 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[0];
}
bool SensorDetectionHeader_DataQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE_REDUCED;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_NOT_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_BLINDNESS;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_TEMPORARY_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_INVALID;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MIN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MAX;
constexpr int SensorDetectionHeader::DataQualifier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_ExtendedQualifier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[1];
}
bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_BLOCKED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INTERNAL_REASON;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MIN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MAX;
constexpr int SensorDetectionHeader::ExtendedQualifier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_Color_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[2];
}
bool CameraDetection_Color_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CameraDetection_Color CameraDetection::COLOR_UNKNOWN;
constexpr CameraDetection_Color CameraDetection::COLOR_OTHER;
constexpr CameraDetection_Color CameraDetection::COLOR_BLACK;
constexpr CameraDetection_Color CameraDetection::COLOR_GREY;
constexpr CameraDetection_Color CameraDetection::COLOR_WHITE;
constexpr CameraDetection_Color CameraDetection::COLOR_YELLOW;
constexpr CameraDetection_Color CameraDetection::COLOR_ORANGE;
constexpr CameraDetection_Color CameraDetection::COLOR_RED;
constexpr CameraDetection_Color CameraDetection::COLOR_VIOLET;
constexpr CameraDetection_Color CameraDetection::COLOR_BLUE;
constexpr CameraDetection_Color CameraDetection::COLOR_GREEN;
constexpr CameraDetection_Color CameraDetection::COLOR_REFLECTIVE;
constexpr CameraDetection_Color CameraDetection::Color_MIN;
constexpr CameraDetection_Color CameraDetection::Color_MAX;
constexpr int CameraDetection::Color_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_ImageShapeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[3];
}
bool CameraDetection_ImageShapeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_UNKNOWN;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_OTHER;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_BOX;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_ELLIPSE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYGON;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYLINE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT_CLOUD;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MIN;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MAX;
constexpr int CameraDetection::ImageShapeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionClassification_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[4];
}
bool DetectionClassification_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FeatureData::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureData>()._has_bits_);
  static const ::osi3::InterfaceVersion& version(const FeatureData* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::InterfaceVersion&
FeatureData::_Internal::version(const FeatureData* msg) {
  return *msg->version_;
}
void FeatureData::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
FeatureData::FeatureData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  radar_sensor_(arena),
  lidar_sensor_(arena),
  ultrasonic_sensor_(arena),
  camera_sensor_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.FeatureData)
}
FeatureData::FeatureData(const FeatureData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      radar_sensor_(from.radar_sensor_),
      lidar_sensor_(from.lidar_sensor_),
      ultrasonic_sensor_(from.ultrasonic_sensor_),
      camera_sensor_(from.camera_sensor_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_version()) {
    version_ = new ::osi3::InterfaceVersion(*from.version_);
  } else {
    version_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:osi3.FeatureData)
}

void FeatureData::SharedCtor() {
version_ = nullptr;
}

FeatureData::~FeatureData() {
  // @@protoc_insertion_point(destructor:osi3.FeatureData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FeatureData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete version_;
}

void FeatureData::ArenaDtor(void* object) {
  FeatureData* _this = reinterpret_cast< FeatureData* >(object);
  (void)_this;
}
void FeatureData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FeatureData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FeatureData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.FeatureData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  radar_sensor_.Clear();
  lidar_sensor_.Clear();
  ultrasonic_sensor_.Clear();
  camera_sensor_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(version_ != nullptr);
    version_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.InterfaceVersion version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.RadarDetectionData radar_sensor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radar_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.LidarDetectionData lidar_sensor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lidar_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ultrasonic_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraDetectionData camera_sensor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_camera_sensor(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FeatureData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.FeatureData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.InterfaceVersion version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::version(this), target, stream);
  }

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_radar_sensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_radar_sensor(i), target, stream);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lidar_sensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_lidar_sensor(i), target, stream);
  }

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ultrasonic_sensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_ultrasonic_sensor(i), target, stream);
  }

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_camera_sensor_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_camera_sensor(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.FeatureData)
  return target;
}

size_t FeatureData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.FeatureData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  total_size += 1UL * this->_internal_radar_sensor_size();
  for (const auto& msg : this->radar_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  total_size += 1UL * this->_internal_lidar_sensor_size();
  for (const auto& msg : this->lidar_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  total_size += 1UL * this->_internal_ultrasonic_sensor_size();
  for (const auto& msg : this->ultrasonic_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  total_size += 1UL * this->_internal_camera_sensor_size();
  for (const auto& msg : this->camera_sensor_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.InterfaceVersion version = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *version_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FeatureData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureData::GetClassData() const { return &_class_data_; }

void FeatureData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FeatureData *>(to)->MergeFrom(
      static_cast<const FeatureData &>(from));
}


void FeatureData::MergeFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.FeatureData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  radar_sensor_.MergeFrom(from.radar_sensor_);
  lidar_sensor_.MergeFrom(from.lidar_sensor_);
  ultrasonic_sensor_.MergeFrom(from.ultrasonic_sensor_);
  camera_sensor_.MergeFrom(from.camera_sensor_);
  if (from._internal_has_version()) {
    _internal_mutable_version()->::osi3::InterfaceVersion::MergeFrom(from._internal_version());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureData::CopyFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.FeatureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureData::IsInitialized() const {
  return true;
}

void FeatureData::InternalSwap(FeatureData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  radar_sensor_.InternalSwap(&other->radar_sensor_);
  lidar_sensor_.InternalSwap(&other->lidar_sensor_);
  ultrasonic_sensor_.InternalSwap(&other->ultrasonic_sensor_);
  camera_sensor_.InternalSwap(&other->camera_sensor_);
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[0]);
}

// ===================================================================

class SensorDetectionHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorDetectionHeader>()._has_bits_);
  static const ::osi3::Timestamp& measurement_time(const SensorDetectionHeader* msg);
  static void set_has_measurement_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cycle_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::MountingPosition& mounting_position(const SensorDetectionHeader* msg);
  static void set_has_mounting_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::MountingPosition& mounting_position_rmse(const SensorDetectionHeader* msg);
  static void set_has_mounting_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_valid_detections(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::osi3::Identifier& sensor_id(const SensorDetectionHeader* msg);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_extended_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::osi3::Timestamp&
SensorDetectionHeader::_Internal::measurement_time(const SensorDetectionHeader* msg) {
  return *msg->measurement_time_;
}
const ::osi3::MountingPosition&
SensorDetectionHeader::_Internal::mounting_position(const SensorDetectionHeader* msg) {
  return *msg->mounting_position_;
}
const ::osi3::MountingPosition&
SensorDetectionHeader::_Internal::mounting_position_rmse(const SensorDetectionHeader* msg) {
  return *msg->mounting_position_rmse_;
}
const ::osi3::Identifier&
SensorDetectionHeader::_Internal::sensor_id(const SensorDetectionHeader* msg) {
  return *msg->sensor_id_;
}
void SensorDetectionHeader::clear_measurement_time() {
  if (measurement_time_ != nullptr) measurement_time_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void SensorDetectionHeader::clear_mounting_position() {
  if (mounting_position_ != nullptr) mounting_position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void SensorDetectionHeader::clear_mounting_position_rmse() {
  if (mounting_position_rmse_ != nullptr) mounting_position_rmse_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void SensorDetectionHeader::clear_sensor_id() {
  if (sensor_id_ != nullptr) sensor_id_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
SensorDetectionHeader::SensorDetectionHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.SensorDetectionHeader)
}
SensorDetectionHeader::SensorDetectionHeader(const SensorDetectionHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_measurement_time()) {
    measurement_time_ = new ::osi3::Timestamp(*from.measurement_time_);
  } else {
    measurement_time_ = nullptr;
  }
  if (from._internal_has_mounting_position()) {
    mounting_position_ = new ::osi3::MountingPosition(*from.mounting_position_);
  } else {
    mounting_position_ = nullptr;
  }
  if (from._internal_has_mounting_position_rmse()) {
    mounting_position_rmse_ = new ::osi3::MountingPosition(*from.mounting_position_rmse_);
  } else {
    mounting_position_rmse_ = nullptr;
  }
  if (from._internal_has_sensor_id()) {
    sensor_id_ = new ::osi3::Identifier(*from.sensor_id_);
  } else {
    sensor_id_ = nullptr;
  }
  ::memcpy(&cycle_counter_, &from.cycle_counter_,
    static_cast<size_t>(reinterpret_cast<char*>(&extended_qualifier_) -
    reinterpret_cast<char*>(&cycle_counter_)) + sizeof(extended_qualifier_));
  // @@protoc_insertion_point(copy_constructor:osi3.SensorDetectionHeader)
}

void SensorDetectionHeader::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&measurement_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&extended_qualifier_) -
    reinterpret_cast<char*>(&measurement_time_)) + sizeof(extended_qualifier_));
}

SensorDetectionHeader::~SensorDetectionHeader() {
  // @@protoc_insertion_point(destructor:osi3.SensorDetectionHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SensorDetectionHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete measurement_time_;
  if (this != internal_default_instance()) delete mounting_position_;
  if (this != internal_default_instance()) delete mounting_position_rmse_;
  if (this != internal_default_instance()) delete sensor_id_;
}

void SensorDetectionHeader::ArenaDtor(void* object) {
  SensorDetectionHeader* _this = reinterpret_cast< SensorDetectionHeader* >(object);
  (void)_this;
}
void SensorDetectionHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorDetectionHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorDetectionHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.SensorDetectionHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(measurement_time_ != nullptr);
      measurement_time_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(mounting_position_ != nullptr);
      mounting_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(mounting_position_rmse_ != nullptr);
      mounting_position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(sensor_id_ != nullptr);
      sensor_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&cycle_counter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&extended_qualifier_) -
        reinterpret_cast<char*>(&cycle_counter_)) + sizeof(extended_qualifier_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorDetectionHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.Timestamp measurement_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_measurement_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cycle_counter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_cycle_counter(&has_bits);
          cycle_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.MountingPosition mounting_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mounting_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.MountingPosition mounting_position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_mounting_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::SensorDetectionHeader_DataQualifier_IsValid(val))) {
            _internal_set_data_qualifier(static_cast<::osi3::SensorDetectionHeader_DataQualifier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_valid_detections = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_number_of_valid_detections(&has_bits);
          number_of_valid_detections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier sensor_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_sensor_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::SensorDetectionHeader_ExtendedQualifier_IsValid(val))) {
            _internal_set_extended_qualifier(static_cast<::osi3::SensorDetectionHeader_ExtendedQualifier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorDetectionHeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.SensorDetectionHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.Timestamp measurement_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::measurement_time(this), target, stream);
  }

  // optional uint64 cycle_counter = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cycle_counter(), target);
  }

  // optional .osi3.MountingPosition mounting_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::mounting_position(this), target, stream);
  }

  // optional .osi3.MountingPosition mounting_position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::mounting_position_rmse(this), target, stream);
  }

  // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_data_qualifier(), target);
  }

  // optional uint32 number_of_valid_detections = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_number_of_valid_detections(), target);
  }

  // optional .osi3.Identifier sensor_id = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::sensor_id(this), target, stream);
  }

  // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_extended_qualifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.SensorDetectionHeader)
  return target;
}

size_t SensorDetectionHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.SensorDetectionHeader)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Timestamp measurement_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *measurement_time_);
    }

    // optional .osi3.MountingPosition mounting_position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mounting_position_);
    }

    // optional .osi3.MountingPosition mounting_position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mounting_position_rmse_);
    }

    // optional .osi3.Identifier sensor_id = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sensor_id_);
    }

    // optional uint64 cycle_counter = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_cycle_counter());
    }

    // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_qualifier());
    }

    // optional uint32 number_of_valid_detections = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_detections());
    }

    // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_extended_qualifier());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorDetectionHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SensorDetectionHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorDetectionHeader::GetClassData() const { return &_class_data_; }

void SensorDetectionHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SensorDetectionHeader *>(to)->MergeFrom(
      static_cast<const SensorDetectionHeader &>(from));
}


void SensorDetectionHeader::MergeFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.SensorDetectionHeader)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_measurement_time()->::osi3::Timestamp::MergeFrom(from._internal_measurement_time());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_mounting_position()->::osi3::MountingPosition::MergeFrom(from._internal_mounting_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_mounting_position_rmse()->::osi3::MountingPosition::MergeFrom(from._internal_mounting_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_sensor_id()->::osi3::Identifier::MergeFrom(from._internal_sensor_id());
    }
    if (cached_has_bits & 0x00000010u) {
      cycle_counter_ = from.cycle_counter_;
    }
    if (cached_has_bits & 0x00000020u) {
      data_qualifier_ = from.data_qualifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      number_of_valid_detections_ = from.number_of_valid_detections_;
    }
    if (cached_has_bits & 0x00000080u) {
      extended_qualifier_ = from.extended_qualifier_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorDetectionHeader::CopyFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.SensorDetectionHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDetectionHeader::IsInitialized() const {
  return true;
}

void SensorDetectionHeader::InternalSwap(SensorDetectionHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, extended_qualifier_)
      + sizeof(SensorDetectionHeader::extended_qualifier_)
      - PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, measurement_time_)>(
          reinterpret_cast<char*>(&measurement_time_),
          reinterpret_cast<char*>(&other->measurement_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDetectionHeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[1]);
}

// ===================================================================

class RadarDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarDetectionData>()._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const RadarDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::SensorDetectionHeader&
RadarDetectionData::_Internal::header(const RadarDetectionData* msg) {
  return *msg->header_;
}
RadarDetectionData::RadarDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  detection_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetectionData)
}
RadarDetectionData::RadarDetectionData(const RadarDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      detection_(from.detection_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::osi3::SensorDetectionHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetectionData)
}

void RadarDetectionData::SharedCtor() {
header_ = nullptr;
}

RadarDetectionData::~RadarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetectionData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RadarDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void RadarDetectionData::ArenaDtor(void* object) {
  RadarDetectionData* _this = reinterpret_cast< RadarDetectionData* >(object);
  (void)_this;
}
void RadarDetectionData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RadarDetectionData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RadarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  detection_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_ != nullptr);
    header_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadarDetectionData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.RadarDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RadarDetectionData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .osi3.RadarDetection detection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_detection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_detection(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetectionData)
  return target;
}

size_t RadarDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetectionData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.RadarDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.SensorDetectionHeader header = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadarDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RadarDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadarDetectionData::GetClassData() const { return &_class_data_; }

void RadarDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RadarDetectionData *>(to)->MergeFrom(
      static_cast<const RadarDetectionData &>(from));
}


void RadarDetectionData::MergeFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetectionData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  detection_.MergeFrom(from.detection_);
  if (from._internal_has_header()) {
    _internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from._internal_header());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetectionData::CopyFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetectionData::IsInitialized() const {
  return true;
}

void RadarDetectionData::InternalSwap(RadarDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  detection_.InternalSwap(&other->detection_);
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarDetectionData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[2]);
}

// ===================================================================

class RadarDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarDetection>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::Identifier& object_id(const RadarDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& position(const RadarDetection* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Spherical3d& position_rmse(const RadarDetection* msg);
  static void set_has_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_radial_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radial_velocity_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_rcs(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_snr(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_point_target_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::osi3::Identifier& ambiguity_id(const RadarDetection* msg);
  static void set_has_ambiguity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_classification(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::osi3::Identifier&
RadarDetection::_Internal::object_id(const RadarDetection* msg) {
  return *msg->object_id_;
}
const ::osi3::Spherical3d&
RadarDetection::_Internal::position(const RadarDetection* msg) {
  return *msg->position_;
}
const ::osi3::Spherical3d&
RadarDetection::_Internal::position_rmse(const RadarDetection* msg) {
  return *msg->position_rmse_;
}
const ::osi3::Identifier&
RadarDetection::_Internal::ambiguity_id(const RadarDetection* msg) {
  return *msg->ambiguity_id_;
}
void RadarDetection::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void RadarDetection::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void RadarDetection::clear_position_rmse() {
  if (position_rmse_ != nullptr) position_rmse_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void RadarDetection::clear_ambiguity_id() {
  if (ambiguity_id_ != nullptr) ambiguity_id_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
RadarDetection::RadarDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetection)
}
RadarDetection::RadarDetection(const RadarDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    object_id_ = new ::osi3::Identifier(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  if (from._internal_has_position()) {
    position_ = new ::osi3::Spherical3d(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_position_rmse()) {
    position_rmse_ = new ::osi3::Spherical3d(*from.position_rmse_);
  } else {
    position_rmse_ = nullptr;
  }
  if (from._internal_has_ambiguity_id()) {
    ambiguity_id_ = new ::osi3::Identifier(*from.ambiguity_id_);
  } else {
    ambiguity_id_ = nullptr;
  }
  ::memcpy(&existence_probability_, &from.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&classification_) -
    reinterpret_cast<char*>(&existence_probability_)) + sizeof(classification_));
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetection)
}

void RadarDetection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&object_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&classification_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(classification_));
}

RadarDetection::~RadarDetection() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RadarDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete object_id_;
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete position_rmse_;
  if (this != internal_default_instance()) delete ambiguity_id_;
}

void RadarDetection::ArenaDtor(void* object) {
  RadarDetection* _this = reinterpret_cast< RadarDetection* >(object);
  (void)_this;
}
void RadarDetection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RadarDetection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RadarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(position_rmse_ != nullptr);
      position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(ambiguity_id_ != nullptr);
      ambiguity_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rcs_) -
        reinterpret_cast<char*>(&existence_probability_)) + sizeof(rcs_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&snr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&classification_) -
        reinterpret_cast<char*>(&snr_)) + sizeof(classification_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadarDetection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double radial_velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_radial_velocity(&has_bits);
          radial_velocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double radial_velocity_rmse = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_radial_velocity_rmse(&has_bits);
          radial_velocity_rmse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double rcs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_rcs(&has_bits);
          rcs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double snr = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_snr(&has_bits);
          snr_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double point_target_probability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          _Internal::set_has_point_target_probability(&has_bits);
          point_target_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier ambiguity_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_ambiguity_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.DetectionClassification classification = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::DetectionClassification_IsValid(val))) {
            _internal_set_classification(static_cast<::osi3::DetectionClassification>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RadarDetection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::object_id(this), target, stream);
  }

  // optional .osi3.Spherical3d position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::position(this), target, stream);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::position_rmse(this), target, stream);
  }

  // optional double radial_velocity = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_radial_velocity(), target);
  }

  // optional double radial_velocity_rmse = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_radial_velocity_rmse(), target);
  }

  // optional double rcs = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_rcs(), target);
  }

  // optional double snr = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_snr(), target);
  }

  // optional double point_target_probability = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_point_target_probability(), target);
  }

  // optional .osi3.Identifier ambiguity_id = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::ambiguity_id(this), target, stream);
  }

  // optional .osi3.DetectionClassification classification = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      11, this->_internal_classification(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetection)
  return target;
}

size_t RadarDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_rmse_);
    }

    // optional .osi3.Identifier ambiguity_id = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ambiguity_id_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double radial_velocity = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double radial_velocity_rmse = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double rcs = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double snr = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double point_target_probability = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .osi3.DetectionClassification classification = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_classification());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RadarDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RadarDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RadarDetection::GetClassData() const { return &_class_data_; }

void RadarDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RadarDetection *>(to)->MergeFrom(
      static_cast<const RadarDetection &>(from));
}


void RadarDetection::MergeFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_object_id()->::osi3::Identifier::MergeFrom(from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_position()->::osi3::Spherical3d::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(from._internal_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_ambiguity_id()->::osi3::Identifier::MergeFrom(from._internal_ambiguity_id());
    }
    if (cached_has_bits & 0x00000010u) {
      existence_probability_ = from.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      radial_velocity_ = from.radial_velocity_;
    }
    if (cached_has_bits & 0x00000040u) {
      radial_velocity_rmse_ = from.radial_velocity_rmse_;
    }
    if (cached_has_bits & 0x00000080u) {
      rcs_ = from.rcs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      snr_ = from.snr_;
    }
    if (cached_has_bits & 0x00000200u) {
      point_target_probability_ = from.point_target_probability_;
    }
    if (cached_has_bits & 0x00000400u) {
      classification_ = from.classification_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetection::CopyFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetection::IsInitialized() const {
  return true;
}

void RadarDetection::InternalSwap(RadarDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadarDetection, classification_)
      + sizeof(RadarDetection::classification_)
      - PROTOBUF_FIELD_OFFSET(RadarDetection, object_id_)>(
          reinterpret_cast<char*>(&object_id_),
          reinterpret_cast<char*>(&other->object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarDetection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[3]);
}

// ===================================================================

class LidarDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<LidarDetectionData>()._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const LidarDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::osi3::SensorDetectionHeader&
LidarDetectionData::_Internal::header(const LidarDetectionData* msg) {
  return *msg->header_;
}
LidarDetectionData::LidarDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  detection_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetectionData)
}
LidarDetectionData::LidarDetectionData(const LidarDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      detection_(from.detection_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::osi3::SensorDetectionHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetectionData)
}

void LidarDetectionData::SharedCtor() {
header_ = nullptr;
}

LidarDetectionData::~LidarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetectionData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LidarDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void LidarDetectionData::ArenaDtor(void* object) {
  LidarDetectionData* _this = reinterpret_cast< LidarDetectionData* >(object);
  (void)_this;
}
void LidarDetectionData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LidarDetectionData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LidarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  detection_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_ != nullptr);
    header_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LidarDetectionData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.LidarDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LidarDetectionData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .osi3.LidarDetection detection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_detection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_detection(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetectionData)
  return target;
}

size_t LidarDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetectionData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.LidarDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .osi3.SensorDetectionHeader header = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LidarDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LidarDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LidarDetectionData::GetClassData() const { return &_class_data_; }

void LidarDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LidarDetectionData *>(to)->MergeFrom(
      static_cast<const LidarDetectionData &>(from));
}


void LidarDetectionData::MergeFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetectionData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  detection_.MergeFrom(from.detection_);
  if (from._internal_has_header()) {
    _internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from._internal_header());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetectionData::CopyFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetectionData::IsInitialized() const {
  return true;
}

void LidarDetectionData::InternalSwap(LidarDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  detection_.InternalSwap(&other->detection_);
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LidarDetectionData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[4]);
}

// ===================================================================

class LidarDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<LidarDetection>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::Identifier& object_id(const LidarDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& position(const LidarDetection* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Spherical3d& position_rmse(const LidarDetection* msg);
  static void set_has_position_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_intensity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free_space_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_classification(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_reflectivity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_echo_pulse_width(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::osi3::Identifier&
LidarDetection::_Internal::object_id(const LidarDetection* msg) {
  return *msg->object_id_;
}
const ::osi3::Spherical3d&
LidarDetection::_Internal::position(const LidarDetection* msg) {
  return *msg->position_;
}
const ::osi3::Spherical3d&
LidarDetection::_Internal::position_rmse(const LidarDetection* msg) {
  return *msg->position_rmse_;
}
void LidarDetection::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LidarDetection::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void LidarDetection::clear_position_rmse() {
  if (position_rmse_ != nullptr) position_rmse_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
LidarDetection::LidarDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetection)
}
LidarDetection::LidarDetection(const LidarDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    object_id_ = new ::osi3::Identifier(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  if (from._internal_has_position()) {
    position_ = new ::osi3::Spherical3d(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_position_rmse()) {
    position_rmse_ = new ::osi3::Spherical3d(*from.position_rmse_);
  } else {
    position_rmse_ = nullptr;
  }
  ::memcpy(&existence_probability_, &from.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&classification_) -
    reinterpret_cast<char*>(&existence_probability_)) + sizeof(classification_));
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetection)
}

void LidarDetection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&object_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&classification_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(classification_));
}

LidarDetection::~LidarDetection() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LidarDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete object_id_;
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete position_rmse_;
}

void LidarDetection::ArenaDtor(void* object) {
  LidarDetection* _this = reinterpret_cast< LidarDetection* >(object);
  (void)_this;
}
void LidarDetection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LidarDetection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LidarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(position_rmse_ != nullptr);
      position_rmse_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&free_space_probability_) -
        reinterpret_cast<char*>(&existence_probability_)) + sizeof(free_space_probability_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&reflectivity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&classification_) -
        reinterpret_cast<char*>(&reflectivity_)) + sizeof(classification_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LidarDetection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d position_rmse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_position_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double height_rmse = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_height_rmse(&has_bits);
          height_rmse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double intensity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_intensity(&has_bits);
          intensity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double free_space_probability = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_free_space_probability(&has_bits);
          free_space_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.DetectionClassification classification = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::DetectionClassification_IsValid(val))) {
            _internal_set_classification(static_cast<::osi3::DetectionClassification>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double reflectivity = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_reflectivity(&has_bits);
          reflectivity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double echo_pulse_width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 89)) {
          _Internal::set_has_echo_pulse_width(&has_bits);
          echo_pulse_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LidarDetection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::object_id(this), target, stream);
  }

  // optional .osi3.Spherical3d position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::position(this), target, stream);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::position_rmse(this), target, stream);
  }

  // optional double height = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_height(), target);
  }

  // optional double height_rmse = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_height_rmse(), target);
  }

  // optional double intensity = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_intensity(), target);
  }

  // optional double free_space_probability = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_free_space_probability(), target);
  }

  // optional .osi3.DetectionClassification classification = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_classification(), target);
  }

  // optional double reflectivity = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_reflectivity(), target);
  }

  // optional double echo_pulse_width = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_echo_pulse_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetection)
  return target;
}

size_t LidarDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_rmse_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double height = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double height_rmse = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double intensity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double free_space_probability = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional double reflectivity = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double echo_pulse_width = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional .osi3.DetectionClassification classification = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_classification());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LidarDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LidarDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LidarDetection::GetClassData() const { return &_class_data_; }

void LidarDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LidarDetection *>(to)->MergeFrom(
      static_cast<const LidarDetection &>(from));
}


void LidarDetection::MergeFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_object_id()->::osi3::Identifier::MergeFrom(from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_position()->::osi3::Spherical3d::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(from._internal_position_rmse());
    }
    if (cached_has_bits & 0x00000008u) {
      existence_probability_ = from.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000020u) {
      height_rmse_ = from.height_rmse_;
    }
    if (cached_has_bits & 0x00000040u) {
      intensity_ = from.intensity_;
    }
    if (cached_has_bits & 0x00000080u) {
      free_space_probability_ = from.free_space_probability_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      reflectivity_ = from.reflectivity_;
    }
    if (cached_has_bits & 0x00000200u) {
      echo_pulse_width_ = from.echo_pulse_width_;
    }
    if (cached_has_bits & 0x00000400u) {
      classification_ = from.classification_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetection::CopyFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetection::IsInitialized() const {
  return true;
}

void LidarDetection::InternalSwap(LidarDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LidarDetection, classification_)
      + sizeof(LidarDetection::classification_)
      - PROTOBUF_FIELD_OFFSET(LidarDetection, object_id_)>(
          reinterpret_cast<char*>(&object_id_),
          reinterpret_cast<char*>(&other->object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LidarDetection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[5]);
}

// ===================================================================

class UltrasonicDetectionSpecificHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetectionSpecificHeader>()._has_bits_);
  static void set_has_max_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_valid_indirect_detections(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionSpecificHeader)
}
UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(const UltrasonicDetectionSpecificHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_range_, &from.max_range_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_valid_indirect_detections_) -
    reinterpret_cast<char*>(&max_range_)) + sizeof(number_of_valid_indirect_detections_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetectionSpecificHeader)
}

void UltrasonicDetectionSpecificHeader::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_range_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_valid_indirect_detections_) -
    reinterpret_cast<char*>(&max_range_)) + sizeof(number_of_valid_indirect_detections_));
}

UltrasonicDetectionSpecificHeader::~UltrasonicDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionSpecificHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UltrasonicDetectionSpecificHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UltrasonicDetectionSpecificHeader::ArenaDtor(void* object) {
  UltrasonicDetectionSpecificHeader* _this = reinterpret_cast< UltrasonicDetectionSpecificHeader* >(object);
  (void)_this;
}
void UltrasonicDetectionSpecificHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UltrasonicDetectionSpecificHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UltrasonicDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionSpecificHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&max_range_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_valid_indirect_detections_) -
        reinterpret_cast<char*>(&max_range_)) + sizeof(number_of_valid_indirect_detections_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetectionSpecificHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double max_range = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_max_range(&has_bits);
          max_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_valid_indirect_detections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_number_of_valid_indirect_detections(&has_bits);
          number_of_valid_indirect_detections_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UltrasonicDetectionSpecificHeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionSpecificHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double max_range = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_max_range(), target);
  }

  // optional uint32 number_of_valid_indirect_detections = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_number_of_valid_indirect_detections(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionSpecificHeader)
  return target;
}

size_t UltrasonicDetectionSpecificHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionSpecificHeader)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double max_range = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 number_of_valid_indirect_detections = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_indirect_detections());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetectionSpecificHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UltrasonicDetectionSpecificHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetectionSpecificHeader::GetClassData() const { return &_class_data_; }

void UltrasonicDetectionSpecificHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UltrasonicDetectionSpecificHeader *>(to)->MergeFrom(
      static_cast<const UltrasonicDetectionSpecificHeader &>(from));
}


void UltrasonicDetectionSpecificHeader::MergeFrom(const UltrasonicDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionSpecificHeader)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      max_range_ = from.max_range_;
    }
    if (cached_has_bits & 0x00000002u) {
      number_of_valid_indirect_detections_ = from.number_of_valid_indirect_detections_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionSpecificHeader::CopyFrom(const UltrasonicDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetectionSpecificHeader::IsInitialized() const {
  return true;
}

void UltrasonicDetectionSpecificHeader::InternalSwap(UltrasonicDetectionSpecificHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, number_of_valid_indirect_detections_)
      + sizeof(UltrasonicDetectionSpecificHeader::number_of_valid_indirect_detections_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, max_range_)>(
          reinterpret_cast<char*>(&max_range_),
          reinterpret_cast<char*>(&other->max_range_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetectionSpecificHeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[6]);
}

// ===================================================================

class UltrasonicDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetectionData>()._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const UltrasonicDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::UltrasonicDetectionSpecificHeader& specific_header(const UltrasonicDetectionData* msg);
  static void set_has_specific_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::SensorDetectionHeader&
UltrasonicDetectionData::_Internal::header(const UltrasonicDetectionData* msg) {
  return *msg->header_;
}
const ::osi3::UltrasonicDetectionSpecificHeader&
UltrasonicDetectionData::_Internal::specific_header(const UltrasonicDetectionData* msg) {
  return *msg->specific_header_;
}
UltrasonicDetectionData::UltrasonicDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  detection_(arena),
  indirect_detection_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionData)
}
UltrasonicDetectionData::UltrasonicDetectionData(const UltrasonicDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      detection_(from.detection_),
      indirect_detection_(from.indirect_detection_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::osi3::SensorDetectionHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_specific_header()) {
    specific_header_ = new ::osi3::UltrasonicDetectionSpecificHeader(*from.specific_header_);
  } else {
    specific_header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetectionData)
}

void UltrasonicDetectionData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&specific_header_) -
    reinterpret_cast<char*>(&header_)) + sizeof(specific_header_));
}

UltrasonicDetectionData::~UltrasonicDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UltrasonicDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete specific_header_;
}

void UltrasonicDetectionData::ArenaDtor(void* object) {
  UltrasonicDetectionData* _this = reinterpret_cast< UltrasonicDetectionData* >(object);
  (void)_this;
}
void UltrasonicDetectionData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UltrasonicDetectionData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UltrasonicDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  detection_.Clear();
  indirect_detection_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(specific_header_ != nullptr);
      specific_header_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetectionData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_indirect_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UltrasonicDetectionData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .osi3.UltrasonicDetection detection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_detection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_detection(i), target, stream);
  }

  // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::specific_header(this), target, stream);
  }

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_indirect_detection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_indirect_detection(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionData)
  return target;
}

size_t UltrasonicDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.UltrasonicDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  total_size += 1UL * this->_internal_indirect_detection_size();
  for (const auto& msg : this->indirect_detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .osi3.SensorDetectionHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *specific_header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UltrasonicDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetectionData::GetClassData() const { return &_class_data_; }

void UltrasonicDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UltrasonicDetectionData *>(to)->MergeFrom(
      static_cast<const UltrasonicDetectionData &>(from));
}


void UltrasonicDetectionData::MergeFrom(const UltrasonicDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  detection_.MergeFrom(from.detection_);
  indirect_detection_.MergeFrom(from.indirect_detection_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_specific_header()->::osi3::UltrasonicDetectionSpecificHeader::MergeFrom(from._internal_specific_header());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionData::CopyFrom(const UltrasonicDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetectionData::IsInitialized() const {
  return true;
}

void UltrasonicDetectionData::InternalSwap(UltrasonicDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  detection_.InternalSwap(&other->detection_);
  indirect_detection_.InternalSwap(&other->indirect_detection_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, specific_header_)
      + sizeof(UltrasonicDetectionData::specific_header_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetectionData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[7]);
}

// ===================================================================

class UltrasonicDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicDetection>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Identifier& object_id(const UltrasonicDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Identifier&
UltrasonicDetection::_Internal::object_id(const UltrasonicDetection* msg) {
  return *msg->object_id_;
}
void UltrasonicDetection::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UltrasonicDetection::UltrasonicDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetection)
}
UltrasonicDetection::UltrasonicDetection(const UltrasonicDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    object_id_ = new ::osi3::Identifier(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  ::memcpy(&existence_probability_, &from.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&existence_probability_)) + sizeof(distance_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetection)
}

void UltrasonicDetection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&object_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(distance_));
}

UltrasonicDetection::~UltrasonicDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UltrasonicDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete object_id_;
}

void UltrasonicDetection::ArenaDtor(void* object) {
  UltrasonicDetection* _this = reinterpret_cast< UltrasonicDetection* >(object);
  (void)_this;
}
void UltrasonicDetection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UltrasonicDetection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UltrasonicDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(object_id_ != nullptr);
    object_id_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&distance_) -
        reinterpret_cast<char*>(&existence_probability_)) + sizeof(distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicDetection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_distance(&has_bits);
          distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UltrasonicDetection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::object_id(this), target, stream);
  }

  // optional double distance = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetection)
  return target;
}

size_t UltrasonicDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double distance = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UltrasonicDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicDetection::GetClassData() const { return &_class_data_; }

void UltrasonicDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UltrasonicDetection *>(to)->MergeFrom(
      static_cast<const UltrasonicDetection &>(from));
}


void UltrasonicDetection::MergeFrom(const UltrasonicDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_object_id()->::osi3::Identifier::MergeFrom(from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      existence_probability_ = from.existence_probability_;
    }
    if (cached_has_bits & 0x00000004u) {
      distance_ = from.distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetection::CopyFrom(const UltrasonicDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicDetection::IsInitialized() const {
  return true;
}

void UltrasonicDetection::InternalSwap(UltrasonicDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetection, distance_)
      + sizeof(UltrasonicDetection::distance_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetection, object_id_)>(
          reinterpret_cast<char*>(&object_id_),
          reinterpret_cast<char*>(&other->object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicDetection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[8]);
}

// ===================================================================

class UltrasonicIndirectDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<UltrasonicIndirectDetection>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::osi3::Identifier& object_id(const UltrasonicIndirectDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ellipsoid_radial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ellipsoid_axial(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::osi3::Identifier& receiver_id(const UltrasonicIndirectDetection* msg);
  static void set_has_receiver_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::osi3::Vector3d& receiver_origin(const UltrasonicIndirectDetection* msg);
  static void set_has_receiver_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::osi3::Identifier&
UltrasonicIndirectDetection::_Internal::object_id(const UltrasonicIndirectDetection* msg) {
  return *msg->object_id_;
}
const ::osi3::Identifier&
UltrasonicIndirectDetection::_Internal::receiver_id(const UltrasonicIndirectDetection* msg) {
  return *msg->receiver_id_;
}
const ::osi3::Vector3d&
UltrasonicIndirectDetection::_Internal::receiver_origin(const UltrasonicIndirectDetection* msg) {
  return *msg->receiver_origin_;
}
void UltrasonicIndirectDetection::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void UltrasonicIndirectDetection::clear_receiver_id() {
  if (receiver_id_ != nullptr) receiver_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void UltrasonicIndirectDetection::clear_receiver_origin() {
  if (receiver_origin_ != nullptr) receiver_origin_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
UltrasonicIndirectDetection::UltrasonicIndirectDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicIndirectDetection)
}
UltrasonicIndirectDetection::UltrasonicIndirectDetection(const UltrasonicIndirectDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    object_id_ = new ::osi3::Identifier(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  if (from._internal_has_receiver_id()) {
    receiver_id_ = new ::osi3::Identifier(*from.receiver_id_);
  } else {
    receiver_id_ = nullptr;
  }
  if (from._internal_has_receiver_origin()) {
    receiver_origin_ = new ::osi3::Vector3d(*from.receiver_origin_);
  } else {
    receiver_origin_ = nullptr;
  }
  ::memcpy(&existence_probability_, &from.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&ellipsoid_axial_) -
    reinterpret_cast<char*>(&existence_probability_)) + sizeof(ellipsoid_axial_));
  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicIndirectDetection)
}

void UltrasonicIndirectDetection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&object_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ellipsoid_axial_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(ellipsoid_axial_));
}

UltrasonicIndirectDetection::~UltrasonicIndirectDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicIndirectDetection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UltrasonicIndirectDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete object_id_;
  if (this != internal_default_instance()) delete receiver_id_;
  if (this != internal_default_instance()) delete receiver_origin_;
}

void UltrasonicIndirectDetection::ArenaDtor(void* object) {
  UltrasonicIndirectDetection* _this = reinterpret_cast< UltrasonicIndirectDetection* >(object);
  (void)_this;
}
void UltrasonicIndirectDetection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UltrasonicIndirectDetection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UltrasonicIndirectDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicIndirectDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(receiver_id_ != nullptr);
      receiver_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(receiver_origin_ != nullptr);
      receiver_origin_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ellipsoid_axial_) -
        reinterpret_cast<char*>(&existence_probability_)) + sizeof(ellipsoid_axial_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UltrasonicIndirectDetection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double ellipsoid_radial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_ellipsoid_radial(&has_bits);
          ellipsoid_radial_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double ellipsoid_axial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_ellipsoid_axial(&has_bits);
          ellipsoid_axial_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier receiver_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Vector3d receiver_origin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_receiver_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UltrasonicIndirectDetection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicIndirectDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::object_id(this), target, stream);
  }

  // optional double ellipsoid_radial = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_ellipsoid_radial(), target);
  }

  // optional double ellipsoid_axial = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ellipsoid_axial(), target);
  }

  // optional .osi3.Identifier receiver_id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::receiver_id(this), target, stream);
  }

  // optional .osi3.Vector3d receiver_origin = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::receiver_origin(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicIndirectDetection)
  return target;
}

size_t UltrasonicIndirectDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicIndirectDetection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional .osi3.Identifier receiver_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *receiver_id_);
    }

    // optional .osi3.Vector3d receiver_origin = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *receiver_origin_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double ellipsoid_radial = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double ellipsoid_axial = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UltrasonicIndirectDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UltrasonicIndirectDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UltrasonicIndirectDetection::GetClassData() const { return &_class_data_; }

void UltrasonicIndirectDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UltrasonicIndirectDetection *>(to)->MergeFrom(
      static_cast<const UltrasonicIndirectDetection &>(from));
}


void UltrasonicIndirectDetection::MergeFrom(const UltrasonicIndirectDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicIndirectDetection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_object_id()->::osi3::Identifier::MergeFrom(from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_receiver_id()->::osi3::Identifier::MergeFrom(from._internal_receiver_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_receiver_origin()->::osi3::Vector3d::MergeFrom(from._internal_receiver_origin());
    }
    if (cached_has_bits & 0x00000008u) {
      existence_probability_ = from.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      ellipsoid_radial_ = from.ellipsoid_radial_;
    }
    if (cached_has_bits & 0x00000020u) {
      ellipsoid_axial_ = from.ellipsoid_axial_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicIndirectDetection::CopyFrom(const UltrasonicIndirectDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicIndirectDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UltrasonicIndirectDetection::IsInitialized() const {
  return true;
}

void UltrasonicIndirectDetection::InternalSwap(UltrasonicIndirectDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, ellipsoid_axial_)
      + sizeof(UltrasonicIndirectDetection::ellipsoid_axial_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, object_id_)>(
          reinterpret_cast<char*>(&object_id_),
          reinterpret_cast<char*>(&other->object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UltrasonicIndirectDetection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[9]);
}

// ===================================================================

class CameraDetectionSpecificHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetectionSpecificHeader>()._has_bits_);
  static void set_has_number_of_valid_points(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionSpecificHeader)
}
CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(const CameraDetectionSpecificHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  number_of_valid_points_ = from.number_of_valid_points_;
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetectionSpecificHeader)
}

void CameraDetectionSpecificHeader::SharedCtor() {
number_of_valid_points_ = 0u;
}

CameraDetectionSpecificHeader::~CameraDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionSpecificHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CameraDetectionSpecificHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CameraDetectionSpecificHeader::ArenaDtor(void* object) {
  CameraDetectionSpecificHeader* _this = reinterpret_cast< CameraDetectionSpecificHeader* >(object);
  (void)_this;
}
void CameraDetectionSpecificHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CameraDetectionSpecificHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CameraDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionSpecificHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  number_of_valid_points_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetectionSpecificHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 number_of_valid_points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_number_of_valid_points(&has_bits);
          number_of_valid_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraDetectionSpecificHeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionSpecificHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 number_of_valid_points = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_number_of_valid_points(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionSpecificHeader)
  return target;
}

size_t CameraDetectionSpecificHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionSpecificHeader)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 number_of_valid_points = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_valid_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetectionSpecificHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CameraDetectionSpecificHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetectionSpecificHeader::GetClassData() const { return &_class_data_; }

void CameraDetectionSpecificHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CameraDetectionSpecificHeader *>(to)->MergeFrom(
      static_cast<const CameraDetectionSpecificHeader &>(from));
}


void CameraDetectionSpecificHeader::MergeFrom(const CameraDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionSpecificHeader)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_number_of_valid_points()) {
    _internal_set_number_of_valid_points(from._internal_number_of_valid_points());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionSpecificHeader::CopyFrom(const CameraDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetectionSpecificHeader::IsInitialized() const {
  return true;
}

void CameraDetectionSpecificHeader::InternalSwap(CameraDetectionSpecificHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(number_of_valid_points_, other->number_of_valid_points_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetectionSpecificHeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[10]);
}

// ===================================================================

class CameraDetectionData::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetectionData>()._has_bits_);
  static const ::osi3::SensorDetectionHeader& header(const CameraDetectionData* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::CameraDetectionSpecificHeader& specific_header(const CameraDetectionData* msg);
  static void set_has_specific_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::SensorDetectionHeader&
CameraDetectionData::_Internal::header(const CameraDetectionData* msg) {
  return *msg->header_;
}
const ::osi3::CameraDetectionSpecificHeader&
CameraDetectionData::_Internal::specific_header(const CameraDetectionData* msg) {
  return *msg->specific_header_;
}
CameraDetectionData::CameraDetectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  detection_(arena),
  point_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionData)
}
CameraDetectionData::CameraDetectionData(const CameraDetectionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      detection_(from.detection_),
      point_(from.point_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::osi3::SensorDetectionHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_specific_header()) {
    specific_header_ = new ::osi3::CameraDetectionSpecificHeader(*from.specific_header_);
  } else {
    specific_header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetectionData)
}

void CameraDetectionData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&specific_header_) -
    reinterpret_cast<char*>(&header_)) + sizeof(specific_header_));
}

CameraDetectionData::~CameraDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CameraDetectionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete specific_header_;
}

void CameraDetectionData::ArenaDtor(void* object) {
  CameraDetectionData* _this = reinterpret_cast< CameraDetectionData* >(object);
  (void)_this;
}
void CameraDetectionData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CameraDetectionData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CameraDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  detection_.Clear();
  point_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != nullptr);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(specific_header_ != nullptr);
      specific_header_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetectionData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraDetection detection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_specific_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .osi3.CameraPoint point = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraDetectionData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .osi3.SensorDetectionHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .osi3.CameraDetection detection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_detection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_detection(i), target, stream);
  }

  // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::specific_header(this), target, stream);
  }

  // repeated .osi3.CameraPoint point = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_point_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_point(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionData)
  return target;
}

size_t CameraDetectionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .osi3.CameraDetection detection = 2;
  total_size += 1UL * this->_internal_detection_size();
  for (const auto& msg : this->detection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .osi3.CameraPoint point = 4;
  total_size += 1UL * this->_internal_point_size();
  for (const auto& msg : this->point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .osi3.SensorDetectionHeader header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *specific_header_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetectionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CameraDetectionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetectionData::GetClassData() const { return &_class_data_; }

void CameraDetectionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CameraDetectionData *>(to)->MergeFrom(
      static_cast<const CameraDetectionData &>(from));
}


void CameraDetectionData::MergeFrom(const CameraDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  detection_.MergeFrom(from.detection_);
  point_.MergeFrom(from.point_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_specific_header()->::osi3::CameraDetectionSpecificHeader::MergeFrom(from._internal_specific_header());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionData::CopyFrom(const CameraDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetectionData::IsInitialized() const {
  return true;
}

void CameraDetectionData::InternalSwap(CameraDetectionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  detection_.InternalSwap(&other->detection_);
  point_.InternalSwap(&other->point_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetectionData, specific_header_)
      + sizeof(CameraDetectionData::specific_header_)
      - PROTOBUF_FIELD_OFFSET(CameraDetectionData, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetectionData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[11]);
}

// ===================================================================

class CameraDetection::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraDetection>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::osi3::Identifier& object_id(const CameraDetection* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Timestamp& time_difference(const CameraDetection* msg);
  static void set_has_time_difference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_image_shape_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shape_classification_background(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shape_classification_foreground(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_shape_classification_flat(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_shape_classification_upright(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shape_classification_ground(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_shape_classification_sky(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_shape_classification_vegetation(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_shape_classification_road(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_shape_classification_non_driving_lane(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_shape_classification_non_road(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_shape_classification_stationary_object(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_shape_classification_moving_object(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_shape_classification_landmark(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_shape_classification_traffic_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_shape_classification_traffic_light(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_shape_classification_road_marking(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_shape_classification_vehicle(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_shape_classification_pedestrian(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_shape_classification_animal(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_shape_classification_pedestrian_front(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_shape_classification_pedestrian_side(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_shape_classification_pedestrian_rear(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_shape_classification_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_color_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::osi3::Identifier& ambiguity_id(const CameraDetection* msg);
  static void set_has_ambiguity_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_first_point_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_number_of_points(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::osi3::ColorDescription& color_description(const CameraDetection* msg);
  static void set_has_color_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::osi3::Identifier&
CameraDetection::_Internal::object_id(const CameraDetection* msg) {
  return *msg->object_id_;
}
const ::osi3::Timestamp&
CameraDetection::_Internal::time_difference(const CameraDetection* msg) {
  return *msg->time_difference_;
}
const ::osi3::Identifier&
CameraDetection::_Internal::ambiguity_id(const CameraDetection* msg) {
  return *msg->ambiguity_id_;
}
const ::osi3::ColorDescription&
CameraDetection::_Internal::color_description(const CameraDetection* msg) {
  return *msg->color_description_;
}
void CameraDetection::clear_object_id() {
  if (object_id_ != nullptr) object_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CameraDetection::clear_time_difference() {
  if (time_difference_ != nullptr) time_difference_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CameraDetection::clear_ambiguity_id() {
  if (ambiguity_id_ != nullptr) ambiguity_id_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CameraDetection::clear_color_description() {
  if (color_description_ != nullptr) color_description_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
CameraDetection::CameraDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetection)
}
CameraDetection::CameraDetection(const CameraDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_object_id()) {
    object_id_ = new ::osi3::Identifier(*from.object_id_);
  } else {
    object_id_ = nullptr;
  }
  if (from._internal_has_time_difference()) {
    time_difference_ = new ::osi3::Timestamp(*from.time_difference_);
  } else {
    time_difference_ = nullptr;
  }
  if (from._internal_has_ambiguity_id()) {
    ambiguity_id_ = new ::osi3::Identifier(*from.ambiguity_id_);
  } else {
    ambiguity_id_ = nullptr;
  }
  if (from._internal_has_color_description()) {
    color_description_ = new ::osi3::ColorDescription(*from.color_description_);
  } else {
    color_description_ = nullptr;
  }
  ::memcpy(&existence_probability_, &from.existence_probability_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_points_) -
    reinterpret_cast<char*>(&existence_probability_)) + sizeof(number_of_points_));
  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetection)
}

void CameraDetection::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&object_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_points_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(number_of_points_));
}

CameraDetection::~CameraDetection() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetection)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CameraDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete object_id_;
  if (this != internal_default_instance()) delete time_difference_;
  if (this != internal_default_instance()) delete ambiguity_id_;
  if (this != internal_default_instance()) delete color_description_;
}

void CameraDetection::ArenaDtor(void* object) {
  CameraDetection* _this = reinterpret_cast< CameraDetection* >(object);
  (void)_this;
}
void CameraDetection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CameraDetection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CameraDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(object_id_ != nullptr);
      object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(time_difference_ != nullptr);
      time_difference_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(ambiguity_id_ != nullptr);
      ambiguity_id_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(color_description_ != nullptr);
      color_description_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&existence_probability_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shape_classification_foreground_) -
        reinterpret_cast<char*>(&existence_probability_)) + sizeof(shape_classification_foreground_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&shape_classification_flat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shape_classification_non_road_) -
        reinterpret_cast<char*>(&shape_classification_flat_)) + sizeof(shape_classification_non_road_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&shape_classification_stationary_object_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shape_classification_pedestrian_) -
        reinterpret_cast<char*>(&shape_classification_stationary_object_)) + sizeof(shape_classification_pedestrian_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&shape_classification_animal_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&first_point_index_) -
        reinterpret_cast<char*>(&shape_classification_animal_)) + sizeof(first_point_index_));
  }
  number_of_points_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraDetection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&_has_bits_);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier object_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Timestamp time_difference = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_time_difference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::CameraDetection_ImageShapeType_IsValid(val))) {
            _internal_set_image_shape_type(static_cast<::osi3::CameraDetection_ImageShapeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_background = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_shape_classification_background(&_has_bits_);
          shape_classification_background_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_foreground = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_shape_classification_foreground(&_has_bits_);
          shape_classification_foreground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_flat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_shape_classification_flat(&_has_bits_);
          shape_classification_flat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_upright = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_shape_classification_upright(&_has_bits_);
          shape_classification_upright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_ground = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_shape_classification_ground(&_has_bits_);
          shape_classification_ground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_sky = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_shape_classification_sky(&_has_bits_);
          shape_classification_sky_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_vegetation = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_shape_classification_vegetation(&_has_bits_);
          shape_classification_vegetation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_road = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_shape_classification_road(&_has_bits_);
          shape_classification_road_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_non_driving_lane = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_shape_classification_non_driving_lane(&_has_bits_);
          shape_classification_non_driving_lane_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_non_road = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_shape_classification_non_road(&_has_bits_);
          shape_classification_non_road_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_stationary_object = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_shape_classification_stationary_object(&_has_bits_);
          shape_classification_stationary_object_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_moving_object = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_shape_classification_moving_object(&_has_bits_);
          shape_classification_moving_object_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_landmark = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_shape_classification_landmark(&_has_bits_);
          shape_classification_landmark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_traffic_sign = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_shape_classification_traffic_sign(&_has_bits_);
          shape_classification_traffic_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_traffic_light = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_shape_classification_traffic_light(&_has_bits_);
          shape_classification_traffic_light_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_road_marking = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_shape_classification_road_marking(&_has_bits_);
          shape_classification_road_marking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_vehicle = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_shape_classification_vehicle(&_has_bits_);
          shape_classification_vehicle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_shape_classification_pedestrian(&_has_bits_);
          shape_classification_pedestrian_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_animal = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_shape_classification_animal(&_has_bits_);
          shape_classification_animal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_front = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_shape_classification_pedestrian_front(&_has_bits_);
          shape_classification_pedestrian_front_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_side = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_shape_classification_pedestrian_side(&_has_bits_);
          shape_classification_pedestrian_side_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shape_classification_pedestrian_rear = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_shape_classification_pedestrian_rear(&_has_bits_);
          shape_classification_pedestrian_rear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double shape_classification_probability = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 217)) {
          _Internal::set_has_shape_classification_probability(&_has_bits_);
          shape_classification_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.CameraDetection.Color color = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::osi3::CameraDetection_Color_IsValid(val))) {
            _internal_set_color(static_cast<::osi3::CameraDetection_Color>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(28, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double color_probability = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 233)) {
          _Internal::set_has_color_probability(&_has_bits_);
          color_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Identifier ambiguity_id = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_ambiguity_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_point_index = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_first_point_index(&_has_bits_);
          first_point_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_points = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_number_of_points(&_has_bits_);
          number_of_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.ColorDescription color_description = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color_description(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraDetection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::object_id(this), target, stream);
  }

  // optional .osi3.Timestamp time_difference = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::time_difference(this), target, stream);
  }

  // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_image_shape_type(), target);
  }

  // optional bool shape_classification_background = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_shape_classification_background(), target);
  }

  // optional bool shape_classification_foreground = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_shape_classification_foreground(), target);
  }

  // optional bool shape_classification_flat = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_shape_classification_flat(), target);
  }

  // optional bool shape_classification_upright = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_shape_classification_upright(), target);
  }

  // optional bool shape_classification_ground = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_shape_classification_ground(), target);
  }

  // optional bool shape_classification_sky = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_shape_classification_sky(), target);
  }

  // optional bool shape_classification_vegetation = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_shape_classification_vegetation(), target);
  }

  // optional bool shape_classification_road = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_shape_classification_road(), target);
  }

  // optional bool shape_classification_non_driving_lane = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_shape_classification_non_driving_lane(), target);
  }

  // optional bool shape_classification_non_road = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_shape_classification_non_road(), target);
  }

  // optional bool shape_classification_stationary_object = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_shape_classification_stationary_object(), target);
  }

  // optional bool shape_classification_moving_object = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_shape_classification_moving_object(), target);
  }

  // optional bool shape_classification_landmark = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_shape_classification_landmark(), target);
  }

  // optional bool shape_classification_traffic_sign = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_shape_classification_traffic_sign(), target);
  }

  // optional bool shape_classification_traffic_light = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_shape_classification_traffic_light(), target);
  }

  // optional bool shape_classification_road_marking = 20;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_shape_classification_road_marking(), target);
  }

  // optional bool shape_classification_vehicle = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_shape_classification_vehicle(), target);
  }

  // optional bool shape_classification_pedestrian = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_shape_classification_pedestrian(), target);
  }

  // optional bool shape_classification_animal = 23;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_shape_classification_animal(), target);
  }

  // optional bool shape_classification_pedestrian_front = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_shape_classification_pedestrian_front(), target);
  }

  // optional bool shape_classification_pedestrian_side = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_shape_classification_pedestrian_side(), target);
  }

  // optional bool shape_classification_pedestrian_rear = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_shape_classification_pedestrian_rear(), target);
  }

  // optional double shape_classification_probability = 27;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(27, this->_internal_shape_classification_probability(), target);
  }

  // optional .osi3.CameraDetection.Color color = 28;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      28, this->_internal_color(), target);
  }

  // optional double color_probability = 29;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(29, this->_internal_color_probability(), target);
  }

  // optional .osi3.Identifier ambiguity_id = 30;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::ambiguity_id(this), target, stream);
  }

  // optional uint32 first_point_index = 31;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(31, this->_internal_first_point_index(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 number_of_points = 32;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(32, this->_internal_number_of_points(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .osi3.ColorDescription color_description = 33;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        33, _Internal::color_description(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetection)
  return target;
}

size_t CameraDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetection)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .osi3.Identifier object_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_id_);
    }

    // optional .osi3.Timestamp time_difference = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_difference_);
    }

    // optional .osi3.Identifier ambiguity_id = 30;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ambiguity_id_);
    }

    // optional .osi3.ColorDescription color_description = 33;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *color_description_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_image_shape_type());
    }

    // optional bool shape_classification_background = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_foreground = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool shape_classification_flat = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_upright = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_ground = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_sky = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_vegetation = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_road = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_non_driving_lane = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_non_road = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool shape_classification_stationary_object = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool shape_classification_moving_object = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_landmark = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_traffic_sign = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_traffic_light = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_road_marking = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_vehicle = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool shape_classification_animal = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_front = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_side = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool shape_classification_pedestrian_rear = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional .osi3.CameraDetection.Color color = 28;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_color());
    }

    // optional double shape_classification_probability = 27;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 8;
    }

    // optional double color_probability = 29;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 8;
    }

    // optional uint32 first_point_index = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_first_point_index());
    }

  }
  // optional uint32 number_of_points = 32;
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_number_of_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CameraDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraDetection::GetClassData() const { return &_class_data_; }

void CameraDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CameraDetection *>(to)->MergeFrom(
      static_cast<const CameraDetection &>(from));
}


void CameraDetection::MergeFrom(const CameraDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetection)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_object_id()->::osi3::Identifier::MergeFrom(from._internal_object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_time_difference()->::osi3::Timestamp::MergeFrom(from._internal_time_difference());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_ambiguity_id()->::osi3::Identifier::MergeFrom(from._internal_ambiguity_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_color_description()->::osi3::ColorDescription::MergeFrom(from._internal_color_description());
    }
    if (cached_has_bits & 0x00000010u) {
      existence_probability_ = from.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      image_shape_type_ = from.image_shape_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      shape_classification_background_ = from.shape_classification_background_;
    }
    if (cached_has_bits & 0x00000080u) {
      shape_classification_foreground_ = from.shape_classification_foreground_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      shape_classification_flat_ = from.shape_classification_flat_;
    }
    if (cached_has_bits & 0x00000200u) {
      shape_classification_upright_ = from.shape_classification_upright_;
    }
    if (cached_has_bits & 0x00000400u) {
      shape_classification_ground_ = from.shape_classification_ground_;
    }
    if (cached_has_bits & 0x00000800u) {
      shape_classification_sky_ = from.shape_classification_sky_;
    }
    if (cached_has_bits & 0x00001000u) {
      shape_classification_vegetation_ = from.shape_classification_vegetation_;
    }
    if (cached_has_bits & 0x00002000u) {
      shape_classification_road_ = from.shape_classification_road_;
    }
    if (cached_has_bits & 0x00004000u) {
      shape_classification_non_driving_lane_ = from.shape_classification_non_driving_lane_;
    }
    if (cached_has_bits & 0x00008000u) {
      shape_classification_non_road_ = from.shape_classification_non_road_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      shape_classification_stationary_object_ = from.shape_classification_stationary_object_;
    }
    if (cached_has_bits & 0x00020000u) {
      shape_classification_moving_object_ = from.shape_classification_moving_object_;
    }
    if (cached_has_bits & 0x00040000u) {
      shape_classification_landmark_ = from.shape_classification_landmark_;
    }
    if (cached_has_bits & 0x00080000u) {
      shape_classification_traffic_sign_ = from.shape_classification_traffic_sign_;
    }
    if (cached_has_bits & 0x00100000u) {
      shape_classification_traffic_light_ = from.shape_classification_traffic_light_;
    }
    if (cached_has_bits & 0x00200000u) {
      shape_classification_road_marking_ = from.shape_classification_road_marking_;
    }
    if (cached_has_bits & 0x00400000u) {
      shape_classification_vehicle_ = from.shape_classification_vehicle_;
    }
    if (cached_has_bits & 0x00800000u) {
      shape_classification_pedestrian_ = from.shape_classification_pedestrian_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      shape_classification_animal_ = from.shape_classification_animal_;
    }
    if (cached_has_bits & 0x02000000u) {
      shape_classification_pedestrian_front_ = from.shape_classification_pedestrian_front_;
    }
    if (cached_has_bits & 0x04000000u) {
      shape_classification_pedestrian_side_ = from.shape_classification_pedestrian_side_;
    }
    if (cached_has_bits & 0x08000000u) {
      shape_classification_pedestrian_rear_ = from.shape_classification_pedestrian_rear_;
    }
    if (cached_has_bits & 0x10000000u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x20000000u) {
      shape_classification_probability_ = from.shape_classification_probability_;
    }
    if (cached_has_bits & 0x40000000u) {
      color_probability_ = from.color_probability_;
    }
    if (cached_has_bits & 0x80000000u) {
      first_point_index_ = from.first_point_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_has_number_of_points()) {
    _internal_set_number_of_points(from._internal_number_of_points());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetection::CopyFrom(const CameraDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraDetection::IsInitialized() const {
  return true;
}

void CameraDetection::InternalSwap(CameraDetection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetection, number_of_points_)
      + sizeof(CameraDetection::number_of_points_)
      - PROTOBUF_FIELD_OFFSET(CameraDetection, object_id_)>(
          reinterpret_cast<char*>(&object_id_),
          reinterpret_cast<char*>(&other->object_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraDetection::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[12]);
}

// ===================================================================

class CameraPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<CameraPoint>()._has_bits_);
  static void set_has_existence_probability(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::osi3::Spherical3d& point(const CameraPoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::osi3::Spherical3d& point_rmse(const CameraPoint* msg);
  static void set_has_point_rmse(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::osi3::Spherical3d&
CameraPoint::_Internal::point(const CameraPoint* msg) {
  return *msg->point_;
}
const ::osi3::Spherical3d&
CameraPoint::_Internal::point_rmse(const CameraPoint* msg) {
  return *msg->point_rmse_;
}
void CameraPoint::clear_point() {
  if (point_ != nullptr) point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CameraPoint::clear_point_rmse() {
  if (point_rmse_ != nullptr) point_rmse_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CameraPoint::CameraPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:osi3.CameraPoint)
}
CameraPoint::CameraPoint(const CameraPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    point_ = new ::osi3::Spherical3d(*from.point_);
  } else {
    point_ = nullptr;
  }
  if (from._internal_has_point_rmse()) {
    point_rmse_ = new ::osi3::Spherical3d(*from.point_rmse_);
  } else {
    point_rmse_ = nullptr;
  }
  existence_probability_ = from.existence_probability_;
  // @@protoc_insertion_point(copy_constructor:osi3.CameraPoint)
}

void CameraPoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&existence_probability_) -
    reinterpret_cast<char*>(&point_)) + sizeof(existence_probability_));
}

CameraPoint::~CameraPoint() {
  // @@protoc_insertion_point(destructor:osi3.CameraPoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CameraPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete point_;
  if (this != internal_default_instance()) delete point_rmse_;
}

void CameraPoint::ArenaDtor(void* object) {
  CameraPoint* _this = reinterpret_cast< CameraPoint* >(object);
  (void)_this;
}
void CameraPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CameraPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CameraPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(point_ != nullptr);
      point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(point_rmse_ != nullptr);
      point_rmse_->Clear();
    }
  }
  existence_probability_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double existence_probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_existence_probability(&has_bits);
          existence_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .osi3.Spherical3d point_rmse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_rmse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CameraPoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double existence_probability = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_existence_probability(), target);
  }

  // optional .osi3.Spherical3d point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::point(this), target, stream);
  }

  // optional .osi3.Spherical3d point_rmse = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::point_rmse(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraPoint)
  return target;
}

size_t CameraPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.CameraPoint)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .osi3.Spherical3d point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *point_);
    }

    // optional .osi3.Spherical3d point_rmse = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *point_rmse_);
    }

    // optional double existence_probability = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CameraPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraPoint::GetClassData() const { return &_class_data_; }

void CameraPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CameraPoint *>(to)->MergeFrom(
      static_cast<const CameraPoint &>(from));
}


void CameraPoint::MergeFrom(const CameraPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraPoint)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_point()->::osi3::Spherical3d::MergeFrom(from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_point_rmse()->::osi3::Spherical3d::MergeFrom(from._internal_point_rmse());
    }
    if (cached_has_bits & 0x00000004u) {
      existence_probability_ = from.existence_probability_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraPoint::CopyFrom(const CameraPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraPoint::IsInitialized() const {
  return true;
}

void CameraPoint::InternalSwap(CameraPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraPoint, existence_probability_)
      + sizeof(CameraPoint::existence_probability_)
      - PROTOBUF_FIELD_OFFSET(CameraPoint, point_)>(
          reinterpret_cast<char*>(&point_),
          reinterpret_cast<char*>(&other->point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraPoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_osi_5ffeaturedata_2eproto_getter, &descriptor_table_osi_5ffeaturedata_2eproto_once,
      file_level_metadata_osi_5ffeaturedata_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::osi3::FeatureData* Arena::CreateMaybeMessage< ::osi3::FeatureData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::FeatureData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::SensorDetectionHeader* Arena::CreateMaybeMessage< ::osi3::SensorDetectionHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::SensorDetectionHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::RadarDetectionData* Arena::CreateMaybeMessage< ::osi3::RadarDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::RadarDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::RadarDetection* Arena::CreateMaybeMessage< ::osi3::RadarDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::RadarDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::LidarDetectionData* Arena::CreateMaybeMessage< ::osi3::LidarDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::LidarDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::LidarDetection* Arena::CreateMaybeMessage< ::osi3::LidarDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::LidarDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetectionSpecificHeader* Arena::CreateMaybeMessage< ::osi3::UltrasonicDetectionSpecificHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetectionSpecificHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetectionData* Arena::CreateMaybeMessage< ::osi3::UltrasonicDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicDetection* Arena::CreateMaybeMessage< ::osi3::UltrasonicDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::UltrasonicIndirectDetection* Arena::CreateMaybeMessage< ::osi3::UltrasonicIndirectDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::UltrasonicIndirectDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetectionSpecificHeader* Arena::CreateMaybeMessage< ::osi3::CameraDetectionSpecificHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetectionSpecificHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetectionData* Arena::CreateMaybeMessage< ::osi3::CameraDetectionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetectionData >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraDetection* Arena::CreateMaybeMessage< ::osi3::CameraDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::osi3::CameraPoint* Arena::CreateMaybeMessage< ::osi3::CameraPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::osi3::CameraPoint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
